[{"_1":2},"posts/stop-using-redux-2023",{"_3":4},"data",{"_5":6,"_7":8},"__raw","\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    blockquote: \"blockquote\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"“If you don’t know whether you need Redux, you don’t need Redux.”\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"—— Dan Abramov\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Over the past few years, the JavaScript community has seen an increasing chorus of voices telling developers to “stop using Redux.” With the rise of tools like React Query, Zustand, Recoil, and built-in features like React’s Context API and useReducer, Redux is often labeled as “boilerplate-heavy,” “outdated,” or even “obsolete.”\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Failure Case\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even with tools like RTK (Redux Toolkit), code often becomes unnecessarily complex. Here's a simple example of managing global user info:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"// fetchUser.ts\\nexport const fetchUser = createAsyncThunk(\\n  'user/fetchUser',\\n  async (id: string) => {\\n    const response = await fetch(`/api/user/${id}`);\\n    return await response.json();\\n  }\\n);\\n// actionTypes.ts\\nexport const FETCH_USER_PENDING = 'FETCH_USER_PENDING'\\n// actions.ts\\nexport const fetchUserPending = () => ({ type: FETCH_USER_PENDING })\\n// reducer.ts\\ncase FETCH_USER_PENDING:\\n  return { ...state, loading: true }\\n// component.tsx\\ndispatch(fetchUserPending())\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A simple user info request ends up scattered across multiple files. When your project scales, this becomes a giant mess of spaghetti.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"A Better Solution\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's try implementing the same logic using Jotai:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const idAtom = atom(1)\\nconst userAtom = atomWithQuery((get) => ({\\n  queryKey: ['users', get(idAtom)],\\n  queryFn: async ({ queryKey: [, id] }) => {\\n    const res = await fetch(`/api/user/${id}`)\\n    return res.json()\\n  },\\n}))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Which Design Principles Redux Violates\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Separation of Concerns & Single Responsibility\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Redux encourages you to split state logic into:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Action types\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Action creators\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Reducers\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Dispatch calls\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It may sound like \\\"decoupling,\\\" but in practice, a simple state change gets fragmented into four separate places.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Encapsulation & Context Isolation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Redux relies on a global singleton store, which means:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Any component can dispatch any action\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"All components share the same state tree\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In medium to large applications, this lack of scoping makes logic hard to encapsulate or modularize.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Local Reasoning\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React is meant to be \\\"component-driven,\\\" where ideally, a component’s behavior should be fully understandable within its own scope.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But in Redux, to understand what a button does, you often have to:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Check the \", _jsx(_components.code, {\n          children: \"dispatch\"\n        }), \" in the component\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Look up the action creator file\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Jump to the reducer to see state changes\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Check the store for how reducers are combined\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Understanding “what this button does” can require jumping across five files.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Points That You Should Drop Redux\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you checked two or more boxes, Redux might no longer be the right fit for your project.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"[ ] Most of your state logic revolves around API requests and UI forms\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"[ ] You feel like every new feature requires a bunch of new files\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"[ ] You've already adopted RTK but development still feels slow\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"[ ] New team members often struggle to understand slices and dispatch\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","attributes",{"_9":10,"_11":12,"_13":14,"_15":16,"_17":18},"title","Why you should stop using Redux in 2023","description","Redux introduces unnecessary complexity in modern React apps, making simpler, more local-first state tools like Jotai or React Query a better choice in 2023.","date",["D",1685577600000],"category","Marketing","banner","/stop-using-redux-2023/preview.png"]
